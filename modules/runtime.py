import pprint
from debugger import DebugPrinter

# should probably really write this in C... would be less work..
# so this is supposed to read symbolic code generated by the compiler
# and execute the generated intermediate code via stack machine.

# OP_PUSHI
# OP_POP
# OP_ADD
# OP_SUB
# OP_MULT
# OP_DIV

pp = pprint.PrettyPrinter(indent=4)

# write this in python first, then write in C. 
class VirtualRunTime:
    def __init__(self):
        self.instructions = []
        self.v_stack = []
        self.v_data_seg = []
        self.op_lookup = {}
        self.instruction_counter = 0
        self.debugger = DebugPrinter()

    def _op_lookup(self, op_code):
        """Because I hate writing if/elses so much and python has no case statements,
        creating a lookup table for which function to execute when op_code is read."""

    def run_dat_code(self):
        """initializes the data stack and starts executing op instructions."""
        self._initialize_data_segment_and_op_lookup()
        op_code = ""

        print("starting execution of intermediate code\n")

        while op_code != 'OP_HALT':
            instruction = self._get_next_instruction()
            op_code = instruction[0]

            if op_code == 'OP_PUSHI':
                self._op_pushi(instruction[1])
                continue

            elif op_code == 'OP_POP':
                self._op_pop(instruction[1])
                continue
            
            elif op_code == 'OP_ADD':
                self._op_add()
                continue

            elif op_code == 'OP_DIV':
                self._op_div()
                continue

            elif op_code == 'OP_MULT':
                self._op_mult()

            elif op_code == 'OP_SUB':
                self._op_sub()
                continue

            elif op_code == 'OP_WRITELN':
                self._op_writeln(instruction[1])
                continue
            
            else:
                if op_code != 'OP_HALT':
                    raise Exception("something went wrong")

        self._print_data_segment()


    def _push(self, arg):
        pass

    def _op_pushi(self, val):
        """push an immediate value on top of the stack"""
        print("pushing %s onto the stack") % val
        self.v_stack.append(val)

    def _op_pop(self, address):
        """pop top value off the stack and push to data segment address"""
        val = self.v_stack.pop()
        print("popping %s off the stack and pushing to %s") % (val, address)
        self.v_data_seg[address] = val

    def _op_add(self):
        """pop top two values off the stack, add them together and push
        it back onto the stack. sorta cheating since im not popping to a register"""
        val1, val2 = self.v_stack.pop(), self.v_stack.pop()
        val1 = int(val1) + int(val2)
        self.v_stack.append(val1)

    def _op_sub(self):
        """pop two values off the stack. subtract them. push back onto stack"""
        val1 = self.v_stack.pop()
        val2 = self.v_stack.pop()
        val1 = int(val2) - int(val1)
        self.v_stack.append(val1)

    def _op_writeln(self, address):
        """prints the contents of address. This is incorrectly implemented.
        This only works if we are printing an identifier. This should work
        while printing expressions e.g. writeln(1+1); """
        print(self.v_data_seg[address])
    
    def _op_mult(self):
        """pop top two values off stack, multiply them and push back onto stack"""
        val1 = self.v_stack.pop()
        val2 = self.v_stack.pop()
        val1 = int(val1) * int(val2)
        self.v_stack.append(val1)

    def _initialize_data_segment_and_op_lookup(self):
        """reads the symbol table and allocates memory for variables.
        since this is written in python, im cheating and each data segment 
        will correspond to a list index value."""
        table = self.symbol_table.return_table()
        self.v_data_seg = len(table.keys()) * [None]
        for k, v in table.iteritems():
            # initialize data segment to null where it has been initialized
            self.v_data_seg[v['address']] = 'NULL'

    def _get_next_instruction(self):
        """increments the 'program counter' and returns the instruction."""
        instruction = self.instructions[self.instruction_counter]
        self.instruction_counter += 1
        return instruction

    def load_instructions(self, instructions):
        """loads set of instructions"""
        self.instructions = instructions

    def load_symbol_table(self, symbol_table):
        self.symbol_table = symbol_table
        self.symbol_table.print_table()

    def print_instructions(self):
        for instruction in self.instructions:
            pp.pprint(instruction)

    def _print_data_segment(self):
        print("\nprinting memory segment\n")
        for num, val in enumerate(self.v_data_seg):
            print "[%s]: %s" % (num, val)



