import pprint
from debugger import DebugPrinter

# should probably really write this in C... would be less work..
# so this is supposed to read symbolic code generated by the compiler
# and execute the generated intermediate code via stack machine.

# OP_PUSHI
# OP_POP
# OP_ADD
# OP_SUBTRACT
# OP_MULTIPLY

pp = pprint.PrettyPrinter(indent=4)

# write this in python first, then write in C. 


class VirtualRunTime:
    def __init__(self):
        self.instructions = []
        self.v_stack = []
        self.v_data_seg = []
        self.op_lookup = {}
        self.instruction_counter = 0
        self.debugger = DebugPrinter()

    def _op_lookup(self, op_code):
        """Because I hate writing if/elses so much and python has no case statements,
        creating a lookup table for which function to execute when op_code is read."""

    def run_dat_code(self):
        """initializes the data stack and starts executing op instructions."""
        self._initialize_data_segment_and_op_lookup()
        op_code = self._get_next_instruction()

        while op_code != 'OP_HALT':
            pass

    def _push(self, arg):
        pass

    def _pushi(self, val):
        """push an immediate value on top of the stack"""
        self.v_stack.append(val)

    def _pop(self, address):
        """pop top value off the stack and push to data segment address"""
        val = self.v_stack.pop()
        self.v_data_seg[address] = val

    def _op_add(self):
        """pop top two values off the stack, add them together and push
        it back onto the stack. sorta cheating since im not popping to a register"""
        val1, val2 = self.v_stack.pop(), self.v_stack.pop()
        val1 = val1 + val2
        self.v_stack.append(val1)

    def _op_sub(self):
        """pop two values off the stack. subtract them. push back onto stack"""
        val1 = self.v_stack.pop()
        val2 = self.v_stack.pop()
        val1 = val2 - val1
        self.v_stack.append(val2)

    def _op_tk_writeln(self, address):
        """prints the contents of address"""
        print(self.v_data_seg[address])
    
    def _op_mult(self):
        pass

    def _initialize_data_segment_and_op_lookup(self):
        """reads the symbol table and allocates memory for variables.
        since this is python...going to simply initialize the data segment as
        a hash table... yes this is bad and super inefficient but who cares!"""
        table = self.symbol_table.return_table()
        self.v_data_seg = len(table.keys()) * [None]
        for k, v in table.iteritems():
            # initialize data segment to null where it has been initialized
            self.v_data_seg[v['address']] = 'NULL'
        print self.v_data_seg

    def _get_next_instruction(self):
        instruction = self.instructions[self.instruction_counter]
        self.instruction_counter += 1
        return instruction

    def load_instructions(self, instructions):
        """loads set of instructions"""
        self.instructions = instructions

    def load_symbol_table(self, symbol_table):
        self.symbol_table = symbol_table
        self.symbol_table.print_table()

    def print_instructions(self):
        for instruction in self.instructions:
            pp.pprint(instruction)



