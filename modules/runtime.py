import pprint
from collections import deque
from debugger import DebugPrinter

# should probably really write this in C... would be less work..
# so this is supposed to read symbolic code generated by the compiler
# and execute the generated intermediate code via stack machine.

# OP_PUSHI
# OP_POP
# OP_ADD
# OP_SUBTRACT
# OP_MULTIPLY

pp = pprint.PrettyPrinter(indent=4)

# write this in python first, then write in C. 


class VirtualRunTime:
    def __init__(self):
        self.instructions = []
        self.v_stack = []
        self.v_data_seg = []
        self.debugger = DebugPrinter()
        self.op_lookup = {}

    def _op_lookup(self, op_code):
        """Because I hate writing if/elses so much and python has no case statements,
        creating a lookup table for which function to execute when op_code is read."""

    def run_dat_code(self):
        """initializes the data stack and starts executing op instructions."""
        self._initialize_data_segment()

        """runs da code."""
        while op_code != 'OP_HALT':
            # run until OP_HALT is seen.
            pass
        pass

    def _push(self, arg):
        pass

    def _pushi(self, arg):
        pass

    def _pop(self, arg):
        pass

    def _op_add(self):
        pass

    def _op_sub(self):
        pass
    
    def _op_mult(self):
        pass

    def _initialize_data_segment_and_op_lookup(self):
        """reads the symbol table and allocates memory for variables.
        since this is python...going to simply initialize the data segment as
        a hash table... yes this is bad but who cares!"""

    def load_instructions(self, instructions):
        """loads set of instructions"""
        self.instructions = instructions

    def load_symbol_table(self, symbol_table):
        self.symbol_table = symbol_table
        self.symbol_table.print_table()

    def print_instructions(self):
        for instruction in self.instructions:
            pp.pprint(instruction)



